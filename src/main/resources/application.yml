server:
  port: 8081

spring:
  profiles:
    # ??????? dev ???? / test ????  / prod ????
    active: dev-secrets
  servlet:
    multipart:
      max-file-size: 10MB # File upload limit, default 1MB not enough.
  jackson:
    default-property-inclusion: non_null
  cloud:
    openfeign:
      # oauth2.enabled: true：Feign 自动通过你配置的 mapTest 客户端去拿 AccessToken，所有 Feign 请求都自动带上 Bearer Token; Bearer Token 是 default-request-headers 之一;
      #
      # 不需要写拦截器/切换手动逻辑，全部用配置即可
      # 自动获取 OAuth2 clientRegistrationId token，并附在 Authorization: Bearer token
      oauth2:
        enabled: true
        # clientRegistrationId: mapTest
        clients:
          map-api: # ----- Maps API FeignClient专用
            clientRegistrationId: mapTest
          weather-api: # ----- 天气API FeignClient专用
            clientRegistrationId: weatherTest
      client:
        # 每个不同的 API，定义一个不同的 Feign 接口和配置块
        config:
          map-api:
            url: https://routes.googleapis.com/directions/v2:computeRoutes
            loggerLevel: basic
            # 每次请求自动加上指定请求头，不需要在代码里 set。
            default-request-headers:
              X-Goog-FieldMask: ${X-Goog-FieldMask}
            # default-query-parameters：每次请求自动加上 key 等参数
            default-query-parameters:
              key: ${key}
          weather-api:
            url: https://apis.map.qq.com/ws/place/v1/suggestion
            loggerLevel: basic
            default-query-parameters:
              key: ${weather.api-key}
  # spring security OAuth2 Client，
  # 是 spring boot/spring security 用来作为OAuth2客户端去主动“代表应用请求授权、登录、获取资源”
  #
  # spring security OAuth2 Client 是一个简化 OAuth2/OIDC 客户端集成的强大组件，可以使得你的应用轻松与第三方认证服务器（如 Google、GitHub、微信等）集成。
  #
  # Spring Security OAuth2 Client 是 Spring Security 5.x+ 的重要组件，用于帮助应用连接 OAuth2/OpenID Connect 服务、获取令牌、并使用令牌访问受保护资源。
  # Spring Security OAuth2 Client 主要用于管理 OAuth2 客户端身份，自动处理第三方API访问时的认证授权，常用于：
  # - 获取并管理 OAuth2 Access Token（无论是 client_credentials、authorization_code、password、或 refresh_token 流程）
  # - 自动添加 Authorization Header
  # - 与 OpenFeign 或 RestTemplate 集成，实现无感知安全请求
  #
  # 服务本身作为 OAuth2 Client 调用第三方API
  # 如：
  # - 服务端后台自动调用 Google、Twitch、微信等第三方API, 获取访问令牌 / 自动令牌刷新 / 令牌存储/缓存
  # - 微服务间调用时，每个服务都做自己的认证授权
  #
  #
  # 代表**当前应用（作为Client）**去认证服务器（如 Google、GitHub、阿里云、Twitch、微信等）获取token
  # 管理token的存储、刷新、传递
  # 便于主动调用外部受保护API（和OAuth2 Login用户登录不一样，这边重点是“Server端-Server端”对接）
  #
  # OAuth2 认证流程支持
  # - 授权码模式（authorization_code）
  # - 客户端模式（client_credentials）
  #    ' 多种客户端类型
  #      - 普通Web应用（对接第三方登录/API）
  #      - 纯后端应用（服务间调用）
  #      - 前后端分离的SPA
  # - 密码模式（password）
  # - 刷新令牌（refresh_token）
  #
  # Spring Security OAuth2 Client 的最大好处是极大简化了安全集成，不用再手动获取和维护 token，特别适合：
  # - 后台服务调用第三方
  # - 企业内部对接 OpenFeign
  # - 微服务链路自动安全化
  #
  #
  # Spring Security OAuth2 Client 是一个简化 OAuth2/OIDC 客户端集成的强大组件，可以使得你的应用轻松与第三方认证服务器（如 Google、GitHub、微信等）集成。详细解析：
  #
  #一、核心功能
  # 身份认证：通过 OAuth2/OIDC 协议实现用户登录
  # 资源访问：获取令牌访问受保护资源
  # 令牌管理：自动处理令牌获取、刷新和失效
  # 客户端注册：集中管理多个 OAuth2 提供商
  #二、常见使用场景
  # 三方登录：让用户用 Google/微信/支付宝等账号登录你的应用
  # API授权：应用代表用户调用第三方API（如发推、发微博）
  # 微服务间通信：服务A代表用户调用服务B (Token Relay)
  #后台API调用：使用 client_credentials 流程访问API（不涉及用户）
  #
  # implementation 'org.springframework.security:spring-security-oauth2-client
  #
  # <!-- Spring Boot 项目 -->
  # <dependency>
  #    <groupId>org.springframework.boot</groupId>
  #    <artifactId>spring-boot-starter-oauth2-client</artifactId>
  # </dependency>
  #
  # 核心组件
  # ClientRegistration：OAuth2客户端注册信息
  # OAuth2AuthorizedClient：授权成功后的客户端，包含令牌
  # OAuth2AuthorizedClientRepository：存储授权客户端的位置
  # OAuth2AuthorizedClientService：管理授权客户端
  # OAuth2AuthorizedClientManager：协调授权流程
  security:
    oauth2:
      client:
        # 如果不同 API 使用不同的认证体系，要分别配置 OAuth2 客户端
        registration:
          # 登录集成第三方OAuth2服务, 常见如：GitHub、Google、Facebook、WeChat等登录
          # registration名
          # 授权码模式（网站登录）
          github:
            # OAuth2 认证授权类型
            authorization-grant-type: authorization_code
            client-id: ${github.client.id}
            client-secret: ${github.client.secret}
            redirect-uri: "{baseUrl}/login/oauth2/code/github"
            scope: [ user, email ]
          # 后端服务调用OAuth2保护的API, 如对接支付、云服务、第三方开放平台API
          # registration名
          twitch:
            # OAuth2 认证授权类型
            authorization-grant-type: client_credentials
            # 客户端认证方式
            client-authentication-method: client_secret_post
            # OAuth客户端ID
            client-id: ${Client-Id}
            # OAuth客户端密钥
            client-secret: ${client-secret}
          # 后端服务调用OAuth2保护的API, 如对接支付、云服务、第三方开放平台API
          # registration名
          payment-service:
            # OAuth2 认证授权类型
            authorization-grant-type: client_credentials
            client-id: ${payment.client.id}
            client-secret: ${payment.client.secret}
          # 微服务间安全通信, 服务A调用受保护的服务B接口
          # registration名
          message-service:
            # OAuth2 认证授权类型
            authorization-grant-type: client_credentials
            client-id: ${message.client.id}
            client-secret: ${message.client.secret}
        provider:
          # 与上面registration名要一致
          twitch:
            # 令牌端点
            token-uri: https://id.twitch.tv/oauth2/token
  datasource:
    url: jdbc:postgresql://${DATABASE_URL:localhost}:${DATABASE_PORT:5432}/postgres
    username: ${DATABASE_USERNAME:postgres}
    password: ${DATABASE_PASSWORD:secret}
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      # Do not perform any DDL operations. This is the default setting, suitable for situations where Hibernate is not desired to automatically manage the database structure.
      #      ddl-auto: none
      #      ddl-auto: update: This will automatically update the database schema to match the entity classes when the application starts. Other options include none, create (recreate tables on each startup), and validate (verify that the table structure matches the entity classes).
      ddl-auto: update
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
    database-platform: org.hibernate.spatial.dialect.postgis.PostgisDialect
    show-sql: true
  sql:
    init:
      mode: always
      # schema-locations: "classpath:postgis_extension.sql,classpath:database-init.sql"
      # data-locations: "classpath:config-data.sql"

logging:
  level:
    org.apache.coyote.http11.Http11InputBuffer: TRACE # Incoming http requests
    org.springframework.jdbc.core: DEBUG # SQL
    org.springframework.jdbc.datasource.init: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE

travelplanner:
  gcs:
    bucket: travelplanner-bucket-1
  geocoding:
    key:
  jwt:
    secret-key: 868q0lpi6O/0bTW94LCvjF4/grS8DJuvwBVLrgnLCLs=

# https://platform.deepseek.com/
# https://api-docs.deepseek.com/zh-cn/
deepseek:
  api-key: ${deepseek.api-key}
  base-url: ${deepseek.base-url}  # DeepSeek 的 API 基础 URL
  model: ${deepseek.model}  # 使用的模型名称
  stream: ${deepseek.stream}  # # 开启流式输出

tencent:
  api-key: ${weather.api-key}